// JCom Compiler Toolkit
// Main program constructor
//
// Authors:
//  Steve Palmer
//
// Copyright (C) 2013 Steve Palmer
//
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
// 
// # http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

using System;
using System.Diagnostics;
using System.Diagnostics.SymbolStore;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.InteropServices;

namespace CCompiler {

    /// <summary>
    /// Constructs an object that enscapsulates the executable program
    /// generated by the code generator.
    /// </summary>
    public class Program {

        private readonly AssemblyBuilder _ab;
        private readonly ModuleBuilder _mb;
        private readonly Options _opts;
        private readonly bool _isExecutable;
        private readonly bool _isCOMVisible = true;
        private readonly bool _isCLSCompliant = true;

        private Type _mainType;
        private Emitter _ctorEmitter;
        private ISymbolDocumentWriter _currentDoc;

        /// <summary>
        /// Return the current type.
        /// </summary>
        public JType CurrentType { get; set; }

        /// <summary>
        /// Constructs a Program object with the given options and name. The name determines
        /// the module name and thus should be valid as per module name rules. The isExecutable
        /// flag specifies whether the program is directly executable and thus is an EXE file
        /// or is a library and thus is a DLL.
        /// </summary>
        /// <param name="opts">A set of options</param>
        /// <param name="name">String containing the program name</param>
        /// <param name="isExecutable">Specifies whether or not the program is directly executable</param>
        public Program(Options opts, string name, bool isExecutable) {
            if (opts == null) {
                throw new ArgumentNullException(nameof(opts));
            }
            if (name == null) {
                throw new ArgumentNullException(nameof(name));
            }

            _opts = opts;
            _isExecutable = isExecutable;

            AppDomain ad = AppDomain.CurrentDomain;
            AssemblyName an = new();

            // For .NET conventions, make the initial letter of the name
            // uppercase.
            name = name.CapitaliseString();

            an.Name = name;
            an.Version = new Version(_opts.VersionString);

            bool isSaveable = !string.IsNullOrEmpty(opts.OutputFile);
            AssemblyBuilderAccess access = isSaveable ? AssemblyBuilderAccess.RunAndSave : AssemblyBuilderAccess.Run;
            _ab = ad.DefineDynamicAssembly(an, access);

            // Make this assembly debuggable if the debug option was specified.
            if (_opts.GenerateDebug) {
                AddDebuggable(_ab);
            }

            // Don't make the main class abstract if the program is being run from
            // memory as otherwise the caller will be unable to create an instance.
            TypeAttributes typeAttributes = TypeAttributes.Public;
            if (isSaveable) {
                _mb = _ab.DefineDynamicModule(name, OutputFilename, true);
                typeAttributes |= TypeAttributes.BeforeFieldInit | TypeAttributes.Sealed;
            } else {
                _mb = _ab.DefineDynamicModule(name, true);
            }

            // Create an implicit namespace using the output file name if
            // one is specified.
            string className = string.Empty;
            if (!string.IsNullOrEmpty(opts.OutputFile)) {
                className = string.Concat(opts.OutputFile.CapitaliseString(), ".");
            }

            // Create the default type
            className = string.Concat(className, name);
            CurrentType = new JType(_mb, className, typeAttributes);
        }

        /// <summary>
        /// Do work to complete the program creation.
        /// </summary>
        public void Finish() {
            if (_ctorEmitter != null) {
                _ctorEmitter.Emit0(OpCodes.Ret);
                _ctorEmitter.Save();
            }
        }

        /// <summary>
        /// Create a constructor and adds it to the assembly.
        /// </summary>
        /// <returns></returns>
        public Emitter GetConstructor() {
            if (_ctorEmitter == null) {
                ConstructorBuilder cntb;
                cntb = CurrentType.CreateConstructor(MethodAttributes.Static, Array.Empty<Type>());
                _ctorEmitter = new Emitter(cntb);
            }
            return _ctorEmitter;
        }

        /// <summary>
        /// Creates a method and adds it to the assembly. If a symbol is specified, it uses
        /// the symbol information to create the method. Otherwise it creates a simple method
        /// with no parameters and a void return type.
        /// </summary>
        /// <param name="sym">An optional symbol that defines the method</param>
        /// <returns>An Emitter that should be used to emit code for this method</returns>
        public void CreateMethod(Symbol sym) {
            if (sym == null) {
                throw new ArgumentNullException(nameof(sym));
            }

            // Don't make the entrypoint method public if we're saving this program
            // to a file. However make it public if the -run option is specified as
            // otherwise we can't access the entrypoint method internally.
            MethodAttributes methodAttributes = MethodAttributes.Static;
            if (!sym.Modifier.HasFlag(SymModifier.ENTRYPOINT) || sym.IsExported || _opts.Run) {
                methodAttributes |= MethodAttributes.Public;
            }

            MethodBuilder metb = CurrentType.CreateMethod(sym, methodAttributes);

            sym.Info = metb;
            if (sym.Modifier.HasFlag(SymModifier.ENTRYPOINT)) {
                _ab.SetEntryPoint(metb);
            }
        }

        /// <summary>
        /// Sets the current document.
        /// </summary>
        /// <param name="filename">Filename.</param>
        public void SetCurrentDocument(string filename) {
            if (_opts.GenerateDebug) {
                _currentDoc = _mb.DefineDocument(filename, Guid.Empty, Guid.Empty, Guid.Empty);
            }
        }

        /// <summary>
        /// Gets the current document.
        /// </summary>
        /// <returns>The current document.</returns>
        public ISymbolDocumentWriter GetCurrentDocument() {
            return _currentDoc;
        }

        /// <summary>
        /// Create and return an instance of the current type.
        /// </summary>
        /// <returns>The main type.</returns>
        public Type GetMainType() {
            return _mainType ??= CurrentType.Builder.CreateType();
        }

        /// <summary>
        /// Save the program code to the executable.
        /// </summary>
        public void Save() {
            AddCLSCompliant(_ab);
            AddCOMVisiblity(_ab);

            if (_mainType == null) {
                _mainType = GetMainType();
            }
            _ab.Save(OutputFilename);
        }

        /// <summary>
        /// Gets the output filename.
        /// </summary>
        /// <value>The output filename.</value>
        public string OutputFilename {
            get {
                string outputFilename = Path.GetFileName(_opts.OutputFile);
                if (!Path.HasExtension(outputFilename)) {
                    outputFilename = Path.ChangeExtension(outputFilename, _isExecutable ? "exe" : "dll");
                }
                return outputFilename;
            }
        }

        // Make this assembly fully debuggable.
        private static void AddDebuggable(AssemblyBuilder ab) {
            Type type = typeof(DebuggableAttribute);
            ConstructorInfo ctor = type.GetConstructor(new [] { typeof(DebuggableAttribute.DebuggingModes) } );
            CustomAttributeBuilder caBuilder = new(ctor, new object[] { 
                                                        DebuggableAttribute.DebuggingModes.DisableOptimizations | 
                                                        DebuggableAttribute.DebuggingModes.Default });
            ab.SetCustomAttribute(caBuilder);
        }

        // Mark this assembly as CLS Compliant.
        private void AddCLSCompliant(AssemblyBuilder ab) {
            Type type = typeof(CLSCompliantAttribute);
            ConstructorInfo ctor = type.GetConstructor(new [] { typeof(bool) } );
            CustomAttributeBuilder caBuilder = new(ctor, new object[] { _isCLSCompliant });
            ab.SetCustomAttribute(caBuilder);
        }

        // Mark this assembly as COM Visible.
        private void AddCOMVisiblity(AssemblyBuilder ab) {
            Type type = typeof(ComVisibleAttribute);
            ConstructorInfo ctor = type.GetConstructor(new [] { typeof(bool) } );
            CustomAttributeBuilder caBuilder = new(ctor, new object[] { _isCOMVisible });
            ab.SetCustomAttribute(caBuilder);
        }
    }
}