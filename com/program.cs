// JCom Compiler Toolkit
// Main program constructor
//
// Authors:
//  Steve Palmer
//
// Copyright (C) 2013 Steve Palmer
//
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
// 
// # http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

using System;
using System.Diagnostics;
using System.Diagnostics.SymbolStore;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.InteropServices;

namespace CCompiler {

    /// <summary>
    /// Constructs a program definition object.
    /// </summary>
    public class ProgramDefinition : ParseNode {

        /// <summary>
        /// Gets or sets the global symbol table.
        /// </summary>
        /// <value>The globals.</value>
        public SymbolCollection Globals { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether this program is executable.
        /// An executable program has a Main method.
        /// </summary>
        /// <value><c>true</c> if this instance is executable; otherwise, <c>false</c>.</value>
        public bool IsExecutable { get; set; }

        /// <summary>
        /// Gets or sets the program name.
        /// </summary>
        /// <value>A string that specifies the program name</value>
        public string Name { get; set; }

        /// <summary>
        /// Gets or sets the root of the parse tree.
        /// </summary>
        /// <value>The parse tree root</value>
        public BlockParseNode Root { get; set; }

        /// <summary>
        /// Dumps the contents of this parse node to the ParseNode XML
        /// output under the specified parent node.
        /// </summary>
        /// <param name="root">The parent XML node</param>
        public override void Dump(ParseNodeXml root) {
            ParseNodeXml blockNode = root.Node("Program");
            blockNode.Attribute("Name", Name);
            blockNode.Attribute("IsExecutable", IsExecutable.ToString());
            Globals.Dump(blockNode);
            Root.Dump(blockNode);
        }
    }

    /// <summary>
    /// Constructs an object that enscapsulates the executable program
    /// generated by the code generator.
    /// </summary>
    public class Program {

        private readonly AssemblyBuilder _ab;
        private readonly ModuleBuilder _mb;
        private readonly TypeBuilder _tb;
        private readonly Options _opts;
        private readonly bool _isExecutable;
        private readonly bool _isCOMVisible = true;
        private readonly bool _isCLSCompliant = true;

        private Type _mainType;
        private Emitter _ctorEmitter;
        private ISymbolDocumentWriter _currentDoc;

        /// <summary>
        /// Constructs a Program object with the given options and name. The name determines
        /// the module name and thus should be valid as per module name rules. The isExecutable
        /// flag specifies whether the program is directly executable and thus is an EXE file
        /// or is a library and thus is a DLL.
        /// </summary>
        /// <param name="opts">A set of options</param>
        /// <param name="name">String containing the program name</param>
        /// <param name="isExecutable">Specifies whether or not the program is directly executable</param>
        public Program(Options opts, string name, bool isExecutable) {
            if (opts == null) {
                throw new ArgumentNullException(nameof(opts));
            }
            if (name == null) {
                throw new ArgumentNullException(nameof(name));
            }

            _opts = opts;
            _isExecutable = isExecutable;

            AppDomain ad = AppDomain.CurrentDomain;
            AssemblyName an = new();

            // For .NET conventions, make the initial letter of the name
            // uppercase.
            name = name.CapitaliseString();

            an.Name = name;
            an.Version = new Version(_opts.VersionString);

            bool isSaveable = !string.IsNullOrEmpty(opts.OutputFile);
            AssemblyBuilderAccess access = isSaveable ? AssemblyBuilderAccess.RunAndSave : AssemblyBuilderAccess.Run;
            _ab = ad.DefineDynamicAssembly(an, access);

            // Make this assembly debuggable if the debug option was specified.
            if (_opts.GenerateDebug) {
                AddDebuggable(_ab);
            }

            // Don't make the main class abstract if the program is being run from
            // memory as otherwise the caller will be unable to create an instance.
            TypeAttributes typeAttributes = TypeAttributes.Public;
            if (isSaveable) {
                _mb = _ab.DefineDynamicModule(name, OutputFilename, true);
                typeAttributes |= TypeAttributes.BeforeFieldInit | TypeAttributes.Sealed;
            } else {
                _mb = _ab.DefineDynamicModule(name, true);
            }

            // Create an implicit namespace using the output file name if
            // one is specified.
            string className = string.Empty;
            if (!string.IsNullOrEmpty(opts.OutputFile)) {
                className = string.Concat(opts.OutputFile.CapitaliseString(), ".");
            }
            className = string.Concat(className, name);
            _tb = _mb.DefineType(className, typeAttributes);
        }

        /// <summary>
        /// Do work to complete the program creation.
        /// </summary>
        public void Finish() {
            if (_ctorEmitter != null) {
                _ctorEmitter.Emit0(OpCodes.Ret);
                _ctorEmitter.Save();
            }
        }

        /// <summary>
        /// Create a constructor and adds it to the assembly.
        /// </summary>
        /// <returns></returns>
        public Emitter GetConstructor() {
            if (_ctorEmitter == null) {
                ConstructorBuilder cntb;
                cntb = _tb.DefineConstructor(MethodAttributes.Static, CallingConventions.Standard, new Type[0]);
                _ctorEmitter = new Emitter(cntb);
            }
            return _ctorEmitter;
        }

        /// <summary>
        /// Creates a method and adds it to the assembly. If a symbol is specified, it uses
        /// the symbol information to create the method. Otherwise it creates a simple method
        /// with no parameters and a void return type.
        /// </summary>
        /// <param name="sym">An optional symbol that defines the method</param>
        /// <returns>An Emitter that should be used to emit code for this method</returns>
        public void CreateMethod(Symbol sym) {
            if (sym == null) {
                throw new ArgumentNullException(nameof(sym));
            }

            int paramCount = (sym.Parameters != null) ? sym.Parameters.Count : 0;
            Type retType;

            Type [] paramTypes = new Type[paramCount];
            bool isFunction = sym.RetVal != null || sym.Class == SymClass.FUNCTION;
            
            for (int c = 0; c < paramCount; ++c) {
                Symbol param = sym.Parameters[c];
                if (param == null) {
                    throw new NullReferenceException("Parameters");
                }
                Debug.Assert(param.IsParameter);
                Type thisType = param.SystemType;
                if (param.Linkage == SymLinkage.BYREF) {
                    thisType = thisType.MakeByRefType();
                }
                paramTypes[c] = thisType;
                param.ParameterIndex = c;
            }
            if (isFunction) {
                retType = Symbol.SymTypeToSystemType(sym.Type);
            } else {
                retType = typeof(void);
            }

            // Don't make the entrypoint method public if we're saving this program
            // to a file. However make it public if the -run option is specified as
            // otherwise we can't access the entrypoint method internally.
            MethodAttributes methodAttributes = MethodAttributes.Static;
            if (!sym.Modifier.HasFlag(SymModifier.ENTRYPOINT) || sym.IsExported || _opts.Run) {
                methodAttributes |= MethodAttributes.Public;
            }

            MethodBuilder metb = _tb.DefineMethod(sym.Name, methodAttributes, retType, paramTypes);
            int paramIndex = 0;
            if (isFunction) {
                metb.DefineParameter(paramIndex++, ParameterAttributes.Retval, retType.Name);
            }
            
            // For each parameter, set the actual name and type.
            for (int c = 0; c < paramCount; ++c) {
                Symbol param = sym.Parameters[c];
                if (param == null) {
                    throw new NullReferenceException("Parameters");
                }
                if (param.Linkage == SymLinkage.BYREF) {
                    metb.DefineParameter(paramIndex++, ParameterAttributes.In|ParameterAttributes.Out, param.Name);
                } else {
                    metb.DefineParameter(paramIndex++, ParameterAttributes.In, param.Name);
                }
            }
            sym.Info = metb;
            if (sym.Modifier.HasFlag(SymModifier.ENTRYPOINT)) {
                _ab.SetEntryPoint(metb);
            }
        }

        /// <summary>
        /// Sets the current document.
        /// </summary>
        /// <param name="filename">Filename.</param>
        public void SetCurrentDocument(string filename) {
            if (_opts.GenerateDebug) {
                _currentDoc = _mb.DefineDocument(filename, Guid.Empty, Guid.Empty, Guid.Empty);
            }
        }

        /// <summary>
        /// Gets the current document.
        /// </summary>
        /// <returns>The current document.</returns>
        public ISymbolDocumentWriter GetCurrentDocument() {
            return _currentDoc;
        }

        /// <summary>
        /// Return the current type.
        /// </summary>
        /// <returns>The main type.</returns>
        public TypeBuilder GetCurrentType() {
            return _tb;
        }

        /// <summary>
        /// Create and return an instance of the current type.
        /// </summary>
        /// <returns>The main type.</returns>
        public Type GetMainType() {
            return _mainType ??= _tb.CreateType();
        }

        /// <summary>
        /// Save the program code to the executable.
        /// </summary>
        public void Save() {
            AddCLSCompliant(_ab);
            AddCOMVisiblity(_ab);

            if (_mainType == null) {
                _mainType = GetMainType();
            }
            _ab.Save(OutputFilename);
        }

        /// <summary>
        /// Gets the output filename.
        /// </summary>
        /// <value>The output filename.</value>
        public string OutputFilename {
            get {
                string outputFilename = Path.GetFileName(_opts.OutputFile);
                if (!Path.HasExtension(outputFilename)) {
                    outputFilename = Path.ChangeExtension(outputFilename, _isExecutable ? "exe" : "dll");
                }
                return outputFilename;
            }
        }

        // Make this assembly fully debuggable.
        private void AddDebuggable(AssemblyBuilder ab) {
            Type type = typeof(DebuggableAttribute);
            ConstructorInfo ctor = type.GetConstructor(new [] { typeof(DebuggableAttribute.DebuggingModes) } );
            CustomAttributeBuilder caBuilder = new(ctor, new object[] { 
                                                        DebuggableAttribute.DebuggingModes.DisableOptimizations | 
                                                        DebuggableAttribute.DebuggingModes.Default });
            ab.SetCustomAttribute(caBuilder);
        }

        // Mark this assembly as CLS Compliant.
        private void AddCLSCompliant(AssemblyBuilder ab) {
            Type type = typeof(CLSCompliantAttribute);
            ConstructorInfo ctor = type.GetConstructor(new [] { typeof(bool) } );
            CustomAttributeBuilder caBuilder = new(ctor, new object[] { _isCLSCompliant });
            ab.SetCustomAttribute(caBuilder);
        }

        // Mark this assembly as COM Visible.
        private void AddCOMVisiblity(AssemblyBuilder ab) {
            Type type = typeof(ComVisibleAttribute);
            ConstructorInfo ctor = type.GetConstructor(new [] { typeof(bool) } );
            CustomAttributeBuilder caBuilder = new(ctor, new object[] { _isCOMVisible });
            ab.SetCustomAttribute(caBuilder);
        }
    }
}